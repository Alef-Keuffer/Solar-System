<!DOCTYPE html PUBLIC '-//W3C//DTD XHTML 1.0 Transitional//EN' 'http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd'>
<html xmlns='http://www.w3.org/1999/xhtml'>
<head>
<title>phi</title>
<meta name='robots' content='noindex,nofollow' />
<meta name='generator' content='GLOBAL-6.6.8' />
<meta http-equiv='Content-Style-Type' content='text/css' />
<link rel='stylesheet' type='text/css' href='../style.css' />
</head>
<body>
<pre>
<span class='curline'><a href='../S/1.html#L253'>phi</a>               253 src/generator.cpp model_sphere_vertex(const float r, const float theta, const float phi, unsigned int *pos, float *points) {</span>
<span class='curline'><a href='../S/1.html#L267'>phi</a>               267 src/generator.cpp     points_vertex(r * sin(theta) * cos(phi), r * sin(phi), r * cos(theta) * cos(phi), pos, points);</span>
<span class='curline'><a href='../S/1.html#L277'>phi</a>               277 src/generator.cpp     const float phi = -M_PI / 2.0f;</span>
<span class='curline'><a href='../S/1.html#L286'>phi</a>               286 src/generator.cpp             model_sphere_vertex(r, theta + s * (i - 1), phi + t * j, &amp;pos, points); // P1'</span>
<span class='curline'><a href='../S/1.html#L287'>phi</a>               287 src/generator.cpp             model_sphere_vertex(r, theta + s * i, phi + t * (j - 1), &amp;pos, points); // P2</span>
<span class='curline'><a href='../S/1.html#L288'>phi</a>               288 src/generator.cpp             model_sphere_vertex(r, theta + s * i, phi + t * j, &amp;pos, points); //P2'</span>
<span class='curline'><a href='../S/1.html#L290'>phi</a>               290 src/generator.cpp             model_sphere_vertex(r, theta + s * (i - 1), phi + t * (j - 1), &amp;pos, points); // P1</span>
<span class='curline'><a href='../S/1.html#L291'>phi</a>               291 src/generator.cpp             model_sphere_vertex(r, theta + s * i, phi + t * (j - 1), &amp;pos, points); // P2</span>
<span class='curline'><a href='../S/1.html#L292'>phi</a>               292 src/generator.cpp             model_sphere_vertex(r, theta + s * (i - 1), phi + t * j, &amp;pos, points); // P1'</span>
<span class='curline'><a href='../S/4.html#L235'>phi</a>               235 src/main.cpp   void sphereVertex(float r, float theta, float phi) {</span>
<span class='curline'><a href='../S/4.html#L236'>phi</a>               236 src/main.cpp       glVertex3d(r * sin(theta) * cos(phi), r * sin(phi), r * cos(theta) * cos(phi));</span>
<span class='curline'><a href='../S/4.html#L251'>phi</a>               251 src/main.cpp       float phi = -M_PI / 2.0f;</span>
<span class='curline'><a href='../S/4.html#L259'>phi</a>               259 src/main.cpp               sphereVertex(r, theta + s * (i - 1), phi + t * j); // P1'</span>
<span class='curline'><a href='../S/4.html#L260'>phi</a>               260 src/main.cpp               sphereVertex(r, theta + s * i, phi + t * (j - 1)); // P2</span>
<span class='curline'><a href='../S/4.html#L261'>phi</a>               261 src/main.cpp               sphereVertex(r, theta + s * i, phi + t * j); //P2'</span>
<span class='curline'><a href='../S/4.html#L264'>phi</a>               264 src/main.cpp               sphereVertex(r, theta + s * (i - 1), phi + t * (j - 1)); // P1</span>
<span class='curline'><a href='../S/4.html#L265'>phi</a>               265 src/main.cpp               sphereVertex(r, theta + s * i, phi + t * (j - 1)); // P2</span>
<span class='curline'><a href='../S/4.html#L266'>phi</a>               266 src/main.cpp               sphereVertex(r, theta + s * (i - 1), phi + t * j); // P1'</span>
</pre>
</body>
</html>
